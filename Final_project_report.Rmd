
PART1. HERE WE WILL READ AND FORMAT OUR DATA IN R.
```{r}
library(igraph)
library(tidyverse)
library(dplyr)
library(stringr)

#List  files and assign to an R object for subsequent reading:
PPIdata_files=list.files(pattern = ".csv")
PPIdata_files = PPIdata_files[!str_detect(PPIdata_files, "Phosphorylation_PTM")]

#Read all files into a list:
PPIdata=lapply(PPIdata_files, read.csv, sep=",", header=T)

#A helper function to extract relavant file names:
name_func<-function(filesname) {
  name<-strsplit(filesname, "_")[[1]][1]
  return(name)
}

#Assign names to each network:
names(PPIdata)<-unlist(lapply(PPIdata_files, name_func))
#---------------------------------------------------
#This part is only needed if the input data is not already filtered

# #A helper function to filter high confidence interactions(not shown here: the score threshold is picked based on best MCC when compared to literature):
# filter_func<-function(datalist){
# 
#   filtered_data<-as_tibble(datalist)%>%filter(Score>2)
#   return(filtered_data)
# }
#
# #Apply filter function to all data files:
# filtered_PPIdata<-lapply(PPIdata, filter_func)
#---------------------------------------------------
```

PART2. HERE WE WILL GENERATE A NETWORK FOR EACH CONDITION AND DO SOME PRELIMINARY DATA VISUALIZATION.

```{r}
#A helper function to make graphs out of edgelist data files; 
makegraph<-function(filtered_data) {
  network_data<-graph_from_data_frame(filtered_data, directed = F) 
  return(network_data)
}

networks_list<-lapply(PPIdata, makegraph)

#A helper function to plot with degree and interaction score information: 
plot_with_degree<-function(network){
  
  
  deg<-igraph::degree(network)
  V(network)$name[deg < 7] <- ''
  E(network)$width <- 0.5*log(E(network)$Score, 2)
  

  plot(network,
                    vertex.label.cex = 0.3, 
                    vertex.size=deg,
                    margin=c(0,0,0,0)
  )
  
  
}
#Apply the helper plotting function to all networks:
lapply(networks_list, plot_with_degree)

#Make pdf files for each plot and name files by condition:
lapply(1:length(networks_list), function(i){
    
    filename <- sprintf('%s.pdf',names(networks_list)[i])  
  
    network <- networks_list[[i]]
    #Open file:
    pdf(filename,width=8,height=8)
    #margins:
    par(mar = c(10,10,10,10))
    #Outside margins:
    par(oma = c(0,0,0,0))
    #Xpd - when TRUE you can draw outside of plotting area into the margins:
    par(xpd = T)
    plot_with_degree(network)
    #close file:
    dev.off()
  })
```
PART3.HERE WE WILL MERGE MULTIPLE NETWORKS FOR MORE SOPHISTICATED ANALYSIS.
```{r}
library(data.table)

#Add extra column to each PPI dataframe to indicate conditions and merge:
rbound_data = lapply(names(PPIdata), function(name) {
  PPIdata[[name]]$condition = name
  return(PPIdata[[name]])
}) %>% rbindlist()

#Make an igraph object:
net <- igraph::graph_from_data_frame(rbound_data, directed=F) 


#Plot the network where node size reflects degree information:
#Extract degree information:
deg<-igraph::degree(net)

#Fix the layout of the network:
fixed_layout <- layout_with_fr(net)

#Assign colors to conditions:
cond_colours = c("baseline" = "royalblue1","poorcarbon" = "khaki2", "cold25C" = "turquoise1", "hu" = "red", "mms" = "orange",  "h2o2" = "hotpink", "rapamycin" = "springgreen")

#Plot a merged network with a fixed layout of vertices and sequentialling adding the edges of conditions:
outputPDFPath = paste0(getwd(), "/conditionalPPI.pdf")
pdf(file=outputPDFPath)
par(mfrow = c(2,4))
cond_colours_inuse = c()
for (index in 1:length(cond_colours)) {
  cond_colours_inuse = c(cond_colours_inuse, cond_colours[index])
  plot(net, edge.color=cond_colours_inuse[E(net)$condition], vertex.color="gray40", edge.curved=.3, vertex.label=NA, vertex.size=log(deg,2), layout=fixed_layout)

}
# legend(1, -1, legend=names(cond_colours),
#        col=cond_colours, lty=1, cex=0.5)
dev.off() 

#Link for the pirateplot and layout for plotting: https://bookdown.org/ndphillips/YaRrr/arranging-plots-with-parmfrow-and-layout.html

#Make a table of degree information for each gene in each condition: 
degTables = lapply(names(PPIdata), function(name) {
  net_temp <- graph_from_data_frame(PPIdata[[name]], directed=F)
  deg_temp<-igraph::degree(net_temp)
  degTable = data.table(gene = names(deg_temp), deg_temp)
  names(degTable)[2] = name
  return(degTable)
})

names(degTables)<-names(PPIdata)

#Merge degree information for each condition:
merged_deg = degTables[[1]]
for (i in 2:length(degTables)) {
  merged_deg = merge(merged_deg, degTables[[i]], all = T)
}

#Assign NA values to 0:
merged_deg[is.na(merged_deg)] <- 0
class(merged_deg)
#Plot distribution of scores across coniditions:
library(yarrr)


pirateplot(formula = Score ~ condition, 
                   data = rbound_data,
                   main = "Conditional PPI score distribution",
                   xlab = "Condition",
                   ylab = "Interaction Score")

#Bind degree information with condition information:
rbound_deg = lapply(names(degTables), function(name) {
  names(degTables[[name]])[2] <- "degree"
  degTables[[name]]$condition = name
  return(degTables[[name]])
}) %>% rbindlist()

pirateplot(formula = degree ~ condition,
                   data = rbound_deg,
                   main = "Conditional degree distribution",
                   xlab = "Condition",
                   ylab = "Degree")
```


```{r}
hist(x = rbound_deg$degree[rbound_deg$condition == "baseline"],
     main = "Conditional degree distribution",
     xlab = "Degree",
     ylab = "Frequency",
     breaks = 30,
     xlim = c(0, 20),
     col = gray(0, .5))

hist(x = rbound_deg$degree[rbound_deg$condition == "poorcarbon"],
     breaks = 30,
     add = TRUE, # Add plot to previous one!
     col = gray(1, .8))
```
```{r}
#Join multiple networks as edge attributes:
cbound_data=PPIdata[[1]]
names(cbound_data)[3]<-names(PPIdata)[1]

for (i in 2:length(PPIdata)){ 

  temp_dataframe<-PPIdata[[i]]
 
  cbound_data<-merge(cbound_data, temp_dataframe, by = c("AD", "DB"), all.x=T, all.y=T)
names(cbound_data)[2+i]<-names(PPIdata)[i]
}

#Set all NA values to  an arbitrarily small number:
cbound_data[is.na(cbound_data)] <- 0.1

#Extract differential interactions compared to the baseline condition and rbind :
dynamic_and_static_PPI<-c()
  for (i in 4:ncol(cbound_data)) {
  #Calculate fold change in PPI score in respect to baseline condition:
  temp_diff<-cbind(cbound_data[,1:2], "foldchange"= cbound_data$baseline/cbound_data[,i])
  #Extract differential PPIs with more than 2 fold change:
   temp_diff_2fold<-subset(temp_diff, (abs(log2(foldchange)) > 1))
   #Extract nondifferential PPIs with less than 2 fold change:
   temp_nondiff_2fold<-subset(temp_diff, (abs(log2(foldchange)) < 1))                       
  temp_diff_2fold$condition=paste0("dynamic in ", colnames(cbound_data)[i])

  temp_nondiff_2fold$condition=paste0("static in ",colnames(cbound_data)[i])
  
  dynamic_and_static_PPI<-rbind(dynamic_and_static_PPI, temp_diff_2fold, temp_nondiff_2fold)
  } 

#ASK KEVIN HOW TO PLOT SUBSET:
plot(type = "n", x = 1)
pirateplot(formula = log(foldchange,1.5) ~  condition, 
                   data = dynamic_and_static_PPI,
                   main = "Differential PPI score distribution",
                   xlab = "Condition",
                   ylab = "Fold change over baseline",
                   sortx = "sequential", xaxt = "n")
text(cex=1, x=0:11, y=-22, unique(dynamic_and_static_PPI$condition), xpd=TRUE, srt=45)

#Look up how shrink the plotting grid so that condition appears at the bottom

plot(type = "n", x = 1)
pirateplot(formula = log(foldchange,1.5) ~  condition, 
                   data = dynamic_and_static_PPI[stringr::str_detect(dynamic_and_static_PPI$condition, "cold25C"),],
                   main = "Differential PPI score distribution",
                   xlab = "Condition",
                   ylab = "Fold change over baseline",
                   sortx = "sequential", xaxt = "n")
text(cex=1, x=0:11, y=-22, unique(dynamic_and_static_PPI$condition), xpd=TRUE, srt=45)

  #ASK KEVIN HOW TO COUNT IN A LOOP:         
phosphorylationPTM<-read.csv("Phosphorylation_PTM.csv", header=T, stringsAsFactors = F) 


Phospho_PTM <- c() 
for (i in 1:nrow(dynamic_and_static_PPI)) {
  Phospho_count<-length(grep(as.character(dynamic_and_static_PPI$AD[i]), phosphorylationPTM$Systematic.Name)) + length(grep(as.character(dynamic_and_static_PPI$DB[i]), phosphorylationPTM$Systematic.Name))
  Phospho_PTM<-c(Phospho_PTM, Phospho_count)
}
dyn_and_stat_phosphoPTM<-cbind(dynamic_and_static_PPI, "phosphoPTM"=Phospho_PTM)

pirateplot(formula = log(Phospho_PTM+0.1,2) ~ condition, 
                   data = dyn_and_stat_phosphoPTM,
                   main = "PTM sites in dynamic and static PPIs",
                   xlab = "Condition",
                   ylab = "Phosphosites")

domain = 100
start = 50
end = 200
if (domain > start & domain < end)
```


